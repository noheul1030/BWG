OOP의 4가지 특징 (Object Oriented Programming) => 객체 지향 프로그래밍

우리가 실생활에서 쓰는 모든 것을 객체라 하며, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 
각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말합니다.
즉, 기능이 아닌 객체가 중심이며 "누가 어떤 일을 할 것인가?"가 핵심이다.

추상화(abstract)
	-공통의 속성이나 기능을 묶어 이름을 붙이는 것을 추상화라고 할수 있다.
	-객체 지향적 관점에서 클래스를 정의하는 것을 추상하라고 할수 있다.
	예를 들어 사자, 고양이 강아지가 있을때 우리는 이것을 각각의 객체라고 하며,
	객체들의 공통적인 동물이라고 표현할 수있는데 이떼 동물로 묶는 행위를 추강화라고 한다.

캡슐화(encapsulation)
	-특정 객체가 독립적으로 역할을 수행하기 위해 필요한 데이터와 기능을 하나로 묶는 것을 캡슐화라고 한다.
	-쉽게 말해 모듈화를 의미한다. 이러한 캡슐화를 통해 정보를 객체 안에 포함시키고, 그정보에 대한 접근은 허용하지 않는 대신,
	필요에 따라 확인할수 있는 인터페이스를 외부에 공개함으로써 정보 은닉 효과도 자연스럽게 따라온다.

상속(inherutance)
	-상위 개념의 특징을 하위 개념이 물려받는것을 상속이라고 한다.
	-상속은 코드의 재사용성을 높이고 확장성을 높여준다.

다형성(polymorphsim)
	-같은 모양의 코드가 다른 행위를 하는 것을 나타낸다. 자바에서는 overriding, overloading이 그방법이다.
	=>오버라이딩(overriding) - 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말한다.
	=>오버로딩(overloading) - 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말한다.

=================================================================================

OOP의 5대 원칙 (SOLID)

SRP (단일 책임 원칙 - single responsebility principle)
	-쉽게 말하면 하나의 클래스에 역할과 책임을 너무 많이 주지 말라는것이다.
	-클래스에 모든 기능을 다 때려넣지 말고 목적과 취지에 맞게 속성과 메서드를 구성함으로 관련된 책임만 주어야한다.

OCP (개발 패쇄 원칙 - open/close principle)
	-자신의 확장에는 열려있어야 하며, 주변의 변화에 대해서는 닫혀 있어야한다.

LSP (리스코프 치환 원칙 - Liskov substitution priciple)
	-하위 클래스의 인스턴스는 상위 클래스의 인터슨터 역할을 하는데 문제가 없어야한다.
	-인터페이스와 클래스 관계, 상위 클래스와 하위 클래스 관계를 얼마나 논리적으로 설계했는냐이다.
	-하위 클래스가 상위클래스의 역할을 대신할 때 논리적으로 맞아 떨어져야한다.

ISP (인터페이스 분리 원칙 - interface segregaion principle)
	-상황에 맞는 메서드만 제공하라는 것이다.
	-어떤 거현 클래스는 자신이 구현하지 않은 인터페이스는 사용하지 않아야한다.

DIP (의족 역전 원칙 dependency inversion principle)
	-추상 클래스 또는 상위 클래스는 구체적인 구현 클래스 또는 하위 클래스에게 의존적이면 안된다는것이다.

=================================================================================

동기 vs. 비동기
우선 차이점부터 설명하자면, 동기는 '직렬적'으로 작동하는 방식이고 비동기는 '병렬적'으로 작동하는 방식이다. 
즉, 비동기란 특정 코드가 끝날때 까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 것을 의미한다.

동기(synchronous)'란 무엇일까?
직렬적으로 태스크를 수행하는 방식이다.
즉, 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식이다. 어떠한 태스크를 처리할 동안 나머지 태스크는 대기한다.
실제로 cpu가 느려지는 것은 아니지만 시스템의 전체적인 효율이 저하된다고 할 수 있다.

비동기 (asynchronous)'란 무엇인가?
병렬적으로 태스크를 수행하는 방식이다.
요청을 보낸 후 응답의 수락 여부와는 상관없이 다음 태스크가 동작하는 방식이다. 
a 태스크가 실행되는 시간 동안 b 태스크를 할 수 있으므로 자원을 효율적으로 사용할 수 있다.
이때, 비동기 요청시 응답 후 처리할 '콜백 함수'를 함께 알려준다. 
따라서 해당 태스크가 완료되었을 때, '콜백 함수'가 호출된다.

=================================================================================

Java의 특징을 설명해주세요.
Java는 객체지향 프로그래밍 언어입니다.
기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.

장점
JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.
GabageCollector를 통한 자동적인 메모리 관리가 가능하다.

단점
JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
다중 상속이나 타입에 엄격하며, 제약이 많다.

=================================================================================

JVM의 역할에 대해 설명해주세요.
JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해줍니다.

=================================================================================

Java의 컴파일 과정에 대해 설명해주세요.
개발자가 .java 파일을 생성한다.
build를 한다.
java compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
Class Loader를 통해 JVM 메모리 내로 로드한다.
실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)

=================================================================================

추상 클래스와 인터페이스를 설명해주시고, 차이에 대해 설명해주세요.

추상클래스는 abstract키워드로 선언되어 있거나 클래스에 하나 이상의 추상메소드가 포함되어있는 클래스입니다. 
추상메서드가 없어도 추상클래스로 선언할 수 있으나 하나라도 있으면 무조건 추상클래스로 선언되어야 합니다.
기존의 클래스에서 공통적으로 사용될 수 있는 부분을 추상화 하여 추상클래스를 만듭니다.
단독으로는 객체를 생성할 수 없으며, 상속을 위한 상위 클래스로 활용하기 위해 사용합니다.
즉, 추상 클래스의 추상 메서드를 하위 클래스가 구체화하여 기능을 확장하는 데 목적이 있습니다.

인터페이스는 interface 키워드를 사용하여 선언하며, 추상메서드의 집합이라고 할 수 있습니다.
내부에 구현되어있는것이 전혀 없기 때문에 인터페이스를 implement한 클래스에서 추상메서드를 구현하여 사용합니다.
구현 객체의 같은 동작을 보장하기 위한 목적으로, 공통적으로 사용되는 기능을 명시하고 구현을 강제하기 위해 사용됩니다.

차이점
서로 다른 목적을 가지고 있습니다.
추상클래스는 추상메서드를 하위클래스가 구체화 하여 기능을 확장하는데 목적이 있습니다.
인터페이스는 정의된 기능 구현을 강제하여 상속받은 클래스들의 같은 동작을 보장하는데 목적이 있습니다.
추상클래스는 단일 상속이지만 인터페이스는 다중상속이 가능합니다.

=================================================================================

싱글톤 패턴에 대해 설명해주세요.
싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다.
인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와
동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용합니다. (메모리 낭비 방지)

싱글톤 패턴의 대표적인 예시는 Spring Bean 입니다.
스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.

=================================================================================

가비지 컬렉션(Garbage Collection)에 대해 설명해주세요.
가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.

가비지 컬렉터란?
더이상 참조되지 않는 메모리인 가비지를 청소해주는 JVM의 실행 엔진의 한요소 입니다.
JVM은 new와 같은 연산에 의해 생성된 객체들 중에서 더이상 참조되지 않는 객체를 정리해줍니다.
가비지 컬렉터는 Heap 영역을 위주로 탐색하며 메모리를 정리해 줍니다.

=================================================================================

자바의 메모리 영역에 대해 설명해주세요.
자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.

	-메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.

	-스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. 
	LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.

	-힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

=================================================================================

클래스와 객체에 대해 설명해주세요.
클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.
객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다.
여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현합니다.
객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

=================================================================================

생성자(Constructor)에 대해 설명해주세요.
생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다.
명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.

=================================================================================

Synchronized에 대해 아는 대로 말해주세요. (동기화)
여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.
데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다.
Synchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있습니다.

=================================================================================

String, StringBuffer, StringBuilder의 차이를 설명해주세요.
String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가집니다.
StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하며,
StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용합니다.
String, StringBuffer, StringBuilder의 차이와 장단점

=================================================================================

접근 제한자(Access Modifier)에 대해 설명해주세요.
변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4 가지 종류가 있습니다.
public - 접근 제한이 없다. (같은 프로젝트 내 어디서든 사용 가능)
protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능하다.
(default) - 해당 패키지 내에서만 접근 가능
private - 해당 클래스에서만 접근 가능

=================================================================================

클래스 멤버 변수 초기화 순서에 대해 설명해주세요.
static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.
필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.
생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking( thread-safe 영역 )

=================================================================================

static에 대해 설명해주세요.
static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있습니다. 
즉, 인스턴스(객체) 생성 없이 바로 사용 가능합니다.
모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됩니다.

=================================================================================

Inner Class(내부 클래스)의 장점에 대해 설명해주세요.
1. 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.
2. 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.
3. 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다.

=================================================================================

Error와 Exception의 차이를 설명해주세요.
Error는 실행 중 일어날 수 있는 치명적 오류를 말합니다. 
컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속합니다.
반면, Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다.


=================================================================================

CheckedException과 UnCheckedException의 차이를 설명해주세요.
CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 합니다.
대표적인 Exception - IOException, ClassNotFoundException 등
UncheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 됩니다.
대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등
RuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스 입니다.

=================================================================================

Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.
hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,
해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 이 두 개가 모두 맞으면 중복 객체입니다.


=================================================================================

 Vector와 List의 차이를 설명해주세요.
벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가집니다.
벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않습니다. 
검색적인 측면에서는 벡터가 우위에 있습니다.
벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있습니다. 멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 
단일쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어집니다.

=================================================================================

제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요.
제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미입니다.
제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.

=================================================================================

java의 컴파일과정을 설명하세요
컴파일이란 고급언어로 작성된 .java파일을 .class파일로 변환하는 과정을 말합니다.

컴파일 과정
첫번째로 프로그래머가 java언어로 소스코드를 작성합니다.
두번째 javac 컴파일러를 사용해 .java소스 파일을 컴파일하고, 바이트코드로 변환된 .class파일을 생성합니다.
세번째 컴파일된 바이트코드인 .class파일을 클래스로더에 전달합니다.
네번째로 클래스 로더는 동적 로딩을 통해 필요한 클래스를 로딩 및 링크하여 런타임 데이터 영역인 jvm의 메모리에 올립니다.
마지막으로 실행엔진은 jvm 메모리에 올라온 바이트코드들을 인터프리터 방식 혹은 jit 컴파일러 방식으로 실행합니다.

=================================================================================

객체지향이 무슨뜻?
어떤 프로그램의 일부분에 해당하는 작은 부품, 즉 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 
하나의 완성된 프로그램을 만드는 프로그래밍 방법론을 뜻한다.

객체란 현실세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합
객체지향 프로그래밍이란 각자의 역할을 지닌 객체들끼리 서로 메세지를 주고받으며 동작할 수 있도록 프로그래밍 하는 것

=================================================================================

업캐스팅 & 다운캐스팅
슈퍼 클래스의 변수에 서브 클래스의 객체가 들어가는 것을 업캐스팅이라 하고, 업캐스팅 된 변수의 타입을 서브 클래스로 변경하는 것을 다운 캐스팅이라고 합니다. 
서브 클래스 객체는 슈퍼 클래스의 메소드 명세를 상속 받기 때문에 슈퍼 클래스의 변수에 들어가 슈퍼 클래스 인 것처럼 사용될 수 있고, 
업 캐스팅 된 변수의 타입이 다시 서브 클래스로 돌아와 본인의 클래스 객체인 것처럼 사용할 수 있습니다.

=================================================================================

클래스, 객체, 인스턴스의 차이
클래스는 객체지향 프로그래밍에서 특정 개체의 속성과 행위를 정의하는 설계도라고 할 수 있습니다. 
클래스는 멤버변수와 메서드로 구성되며 멤버변수는 해당 클래스의 객체들이 가질 수 있는 상태를 정의하고, 
메서드는 객체들이 수행할 수 있는 행위를 정의합니다.

객체는 클래스에 의해 정의된 설계도를 따라 만들어진 실체로, 객체는 클래스의 인스턴스입니다. 
객체는 메모리에 할당되며 각 객체는 고유한 상태를 가지고 클래스에 정의된 행위(메소드)를 수행할 수 있습니다.
인스턴스는 클래스의 객체를 의미합니다. 클래스를 통해 객체를 생성할 때마다 새로운 인스턴스가 생성되는 것입니다. 

인스턴스는 클래스에 정의된 속성과 행위를 가진 객체로 각 인스턴스는 고유한 상태를 가집니다. 
객체가 특정 클래스의 인스턴스라는 것은 해당 객체가 해당 클래스의 설계도에 따라 생성되었다는 것을 의미합니다.

즉, 클래스는 객체의 설계도이며, 객체는 클래스에 정의된 속성과 행위를 가진 실체입니다. 
인스턴스는 클래스의 객체를 나타내는 용어로 사용되며 클래스로 부터 생성된 객체를 의미합니다.

=================================================================================

Call by Reference와 Call by Value의 차이
Call by Value방식은 함수에 인자를 전달할 때 인자값을 복사하여 전달하는 방식입니다. 
이 방식에서는 원본 데이터와 전달된 복사본이 서로 다른 메모리 주소를 가지기 때문에, 
함수 내에서 인자의 값을 변경해도 원본 데이터에는 영향을 미치지 않습니다. C, C++, Java, Python 등이 call by value 방식을 사용합니다.
Call by Reference방식은 함수에 인자를 전달할 때 인자의 메모리 주소를 전달하는 방식입니다. 
함수 호출시에 인자로 전달되는 변수의 레퍼런스를 전달하며 해당 주소를 통해 원본 데이터를 직접 수정할 수 있습니다. C++, Swift, PHP 등이 call by reference 방식을 지원합니다.

꼬리) java의 기본 타입은 call by value고 참조타입은 call by reference다?
놉 java는 call by value로 작동합니다. java의 참조변수에는 원본 객체에 대한 참조를 값으로 복사하여 가지고 있습니다. 
즉 변수가 가지는 값이 레퍼런스이므로 인자로 넘길 때 call by value에 의해 변수가 가지고 있는 레버런스가 복사되어 전달되는것 입니다. 
함수 내에서 객체의 속성을 변경하게 되면 원래 객체에 영항을 줄 수 있지만 함수 내에서 전달된 참조변수 자체를 변경하면 호출자의 원래 참조에는 영향을 주지 않습니다.

=================================================================================

널과 엠티의 차이점?
Null
변수에 아무것도 할당되지(참조하지) 않은 상태를 의미합니다.
Empty
empty(비어있는) : 문자열의 길이가 0임을 의미합니다.

